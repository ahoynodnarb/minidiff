from __future__ import annotations

from builtins import bool as py_bool
from typing import Any, Optional, Sequence, Union

import minidiff as md
import minidiff.typing as mdt

from .definitions import *

def absolute(x: md.Tensor) -> md.Tensor: ...
def abs(x: md.Tensor) -> md.Tensor: ...
def all(x: md.Tensor) -> md.Tensor: ...
def any(x: md.Tensor) -> md.Tensor: ...
def argmax(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def argmin(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def argwhere(x: md.Tensor) -> md.Tensor: ...
def atleast_1d(x: md.Tensor) -> md.Tensor: ...
def atleast_2d(x: md.Tensor) -> md.Tensor: ...
def atleast_3d(x: md.Tensor) -> md.Tensor: ...
def ceil(x: md.Tensor) -> md.Tensor: ...
def copy(x: md.Tensor) -> md.Tensor: ...
def cos(x: md.Tensor) -> md.Tensor: ...
def cosh(x: md.Tensor) -> md.Tensor: ...
def exp(x: md.Tensor) -> md.Tensor: ...
def flatten(x: md.Tensor) -> md.Tensor: ...
def flip(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def floor(x: md.Tensor) -> md.Tensor: ...
def invert(x: md.Tensor) -> md.Tensor: ...
def log(x: md.Tensor) -> md.Tensor: ...
def logical_not(x: md.Tensor) -> md.Tensor: ...
def max(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def mean(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def min(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def prod(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def ravel(x: md.Tensor) -> md.Tensor: ...
def sign(x: md.Tensor) -> md.Tensor: ...
def sin(x: md.Tensor) -> md.Tensor: ...
def sinh(x: md.Tensor) -> md.Tensor: ...
def sqrt(x: md.Tensor) -> md.Tensor: ...
def square(x: md.Tensor) -> md.Tensor: ...
def squeeze(
    x: md.Tensor, axis: Optional[Union[int, Sequence[int]]] = None
) -> md.Tensor: ...
def std(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def sum(
    x: md.Tensor,
    axis: Optional[Union[int, Sequence[int]]] = None,
    keepdims: py_bool = False,
) -> md.Tensor: ...
def tan(x: md.Tensor) -> md.Tensor: ...
def tanh(x: md.Tensor) -> md.Tensor: ...
def transpose(x: md.Tensor, axes: Optional[Sequence[int]] = None) -> md.Tensor: ...
def add(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def astype(x: md.Tensor, type: mdt.dtype) -> md.Tensor: ...
def broadcast_to(x: md.Tensor, shape: Sequence[int]) -> md.Tensor: ...
def dot(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def equal(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def expand_dims(x: md.Tensor, axis: Union[int, Sequence[int]]) -> md.Tensor: ...
def floor_divide(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def getitem(x: mdt.Tensor, index: Any) -> md.Tensor: ...
def greater(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def greater_equal(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def less(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def less_equal(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def logical_and(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def logical_or(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def logical_xor(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def matmul(x: md.Tensor, y: md.Tensor) -> md.Tensor: ...
def mod(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def multiply(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def not_equal(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def power(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def reshape(x: md.Tensor, shape: Union[int, Sequence[int]]) -> md.Tensor: ...
def subtract(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def tensordot(x: md.Tensor, y: md.Tensor) -> md.Tensor: ...
def true_divide(x: mdt.TensorLike, y: mdt.TensorLike) -> md.Tensor: ...
def unbroadcast(x: md.Tensor, shape: Sequence[int]) -> md.Tensor: ...
def clip(
    x: md.Tensor, a_min: Optional[mdt.TensorLike], a_max: Optional[mdt.TensorLike]
) -> md.Tensor: ...
def swapaxes(x: md.Tensor, axis1: int, axis2: int) -> md.Tensor: ...
def where(
    condition: mdt.TensorLike, y: mdt.TensorLike, z: mdt.TensorLike
) -> md.Tensor: ...
